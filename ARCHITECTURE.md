# SpellCompiler-web æ¶æ„æ·±åº¦è§£æ

> **æ³•æœ¯ç¼–è¾‘å™¨å®Œæ•´æŠ€æœ¯æ–‡æ¡£ - ä»å¯è§†åŒ–ç¼–ç¨‹åˆ°æ¸¸æˆæ‰§è¡Œçš„å…¨æµç¨‹æŒ‡å—**

## ğŸ“‹ ç›®å½•

1. [ç³»ç»Ÿæ¦‚è§ˆ](#ç³»ç»Ÿæ¦‚è§ˆ)
2. [æ ¸å¿ƒæ¶æ„](#æ ¸å¿ƒæ¶æ„)
3. [æ•°æ®æµè¯¦è§£](#æ•°æ®æµè¯¦è§£)
4. [å…³é”®æ¨¡å—æ·±å…¥](#å…³é”®æ¨¡å—æ·±å…¥)
5. [æ–‡ä»¶ç»“æ„ä¸èŒè´£](#æ–‡ä»¶ç»“æ„ä¸èŒè´£)
6. [è°ƒè¯•ä¸BUGå®šä½æŒ‡å—](#è°ƒè¯•ä¸bugå®šä½æŒ‡å—)
7. [æ‰©å±•å¼€å‘æŒ‡å—](#æ‰©å±•å¼€å‘æŒ‡å—)

---

## ç³»ç»Ÿæ¦‚è§ˆ

### é¡¹ç›®å®šä½

SpellCompiler-web æ˜¯ä¸€ä¸ª**åŸºäºå¯è§†åŒ–ç¼–ç¨‹çš„æ³•æœ¯ç¼–è¾‘ç³»ç»Ÿ**ï¼Œèåˆäº†ä»¥ä¸‹æŠ€æœ¯ç†å¿µï¼š

- **å¯è§†åŒ–ç¼–ç¨‹**ï¼šä½¿ç”¨ ReactFlow æ„å»ºèŠ‚ç‚¹å›¾å½¢ç¼–è¾‘å™¨
- **å‡½æ•°å¼ç¼–ç¨‹**ï¼šçº¯å‡½æ•°ã€Lambdaè¡¨è¾¾å¼ã€é—­åŒ…ã€æŸ¯é‡ŒåŒ–ã€é€’å½’
- **ç¼–è¯‘å™¨æŠ€æœ¯**ï¼šASTï¼ˆæŠ½è±¡è¯­æ³•æ ‘ï¼‰ã€è§£é‡Šå™¨ã€ç¯å¢ƒç®¡ç†
- **æ¸¸æˆå¼€å‘**ï¼šPhaser 3 æ¸¸æˆå¼•æ“ã€ECSç»„ä»¶ç³»ç»Ÿã€Bossæˆ˜æ–—ç³»ç»Ÿ

### æŠ€æœ¯æ ˆ

| å±‚çº§ | æŠ€æœ¯ | ç‰ˆæœ¬ | ç”¨é€” |
|------|------|------|------|
| **å‰ç«¯æ¡†æ¶** | React | 19 | UI ç»„ä»¶å’ŒçŠ¶æ€ç®¡ç† |
| **ç±»å‹ç³»ç»Ÿ** | TypeScript | 5 | é™æ€ç±»å‹æ£€æŸ¥ |
| **å·¥ä½œæµç¼–è¾‘** | ReactFlow | 11 | å¯è§†åŒ–èŠ‚ç‚¹ç¼–è¾‘å™¨ |
| **æ¸¸æˆå¼•æ“** | Phaser | 3 | 2Dæ¸¸æˆåœºæ™¯å’Œç‰©ç†å¼•æ“ |
| **ECSç³»ç»Ÿ** | bitecs | - | å®ä½“-ç»„ä»¶-ç³»ç»Ÿæ¶æ„ |
| **UIç»„ä»¶åº“** | Mantine | 8 | ç°ä»£åŒ–UIç»„ä»¶ |
| **æ ·å¼** | Tailwind CSS | 4 | å·¥å…·ç±»æ ·å¼ |
| **å¯è§†åŒ–** | Mermaid | 11 | ASTç»“æ„å›¾è¡¨ |
| **æ„å»ºå·¥å…·** | Vite | 7 | å¿«é€Ÿå¼€å‘å’Œæ„å»º |

### åº”ç”¨è·¯ç”±

```
æ ¹è·¯å¾„ ("/")         â†’ Game.tsx (æ¸¸æˆä¸»ç•Œé¢)
ç¼–è¾‘å™¨è·¯å¾„ ("/editor") â†’ Editor.tsx (æ³•æœ¯ç¼–è¾‘å™¨)
```

è·¯ç”±é€»è¾‘åœ¨ `src/main.tsx` ä¸­å¤„ç†ï¼Œæ ¹æ® URL è·¯å¾„åˆ†å‘åˆ°ä¸åŒçš„é¡¶å±‚ç»„ä»¶ã€‚

---

## æ ¸å¿ƒæ¶æ„

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         SpellCompiler-web                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   Editor Module        â”‚    â”‚   Game Module            â”‚   â”‚
â”‚  â”‚  (æ³•æœ¯ç¼–è¾‘å™¨æ¨¡å—)        â”‚    â”‚  (æ¸¸æˆæ‰§è¡Œæ¨¡å—)           â”‚   â”‚
â”‚  â”‚                        â”‚    â”‚                          â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚
â”‚  â”‚  â”‚ React Flow       â”‚  â”‚    â”‚  â”‚ Phaser 3 Game      â”‚ â”‚   â”‚
â”‚  â”‚  â”‚ å¯è§†åŒ–èŠ‚ç‚¹ç¼–è¾‘å™¨   â”‚  â”‚    â”‚  â”‚ æ¸¸æˆä¸»å®ä¾‹          â”‚ â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚
â”‚  â”‚           â†“             â”‚    â”‚           â†“             â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚
â”‚  â”‚  â”‚ flowToIR         â”‚  â”‚    â”‚  â”‚ 20ä¸ªæ¸¸æˆåœºæ™¯         â”‚ â”‚   â”‚
â”‚  â”‚  â”‚ ç¼–è¯‘å™¨ï¼šå›¾â†’AST     â”‚  â”‚    â”‚  â”‚ Level1-20         â”‚ â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚
â”‚  â”‚           â†“             â”‚    â”‚           â†“             â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚
â”‚  â”‚  â”‚ AST (5ç§èŠ‚ç‚¹)     â”‚â†â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”‚ castSpell()        â”‚ â”‚   â”‚
â”‚  â”‚  â”‚ æŠ½è±¡æ³•æœ¯æ ‘         â”‚  â”‚    â”‚  â”‚ æ³•æœ¯æ–½æ”¾            â”‚ â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚
â”‚  â”‚           â†“             â”‚    â”‚           â†“             â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚
â”‚  â”‚  â”‚ Evaluator        â”‚â†â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”‚ Bossç³»ç»Ÿ            â”‚ â”‚   â”‚
â”‚  â”‚  â”‚ è§£é‡Šå™¨æ‰§è¡Œå¼•æ“     â”‚  â”‚    â”‚  â”‚ æŠ€èƒ½Â·AIÂ·çŠ¶æ€        â”‚ â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚
â”‚  â”‚           â†“             â”‚    â”‚           â†“             â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚
â”‚  â”‚  â”‚ Function Library â”‚â†â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”‚ ECS ç»„ä»¶ç³»ç»Ÿ        â”‚ â”‚   â”‚
â”‚  â”‚  â”‚ 6å¤§å‡½æ•°åº“æ¨¡å—      â”‚  â”‚    â”‚  â”‚ health/motionç­‰    â”‚ â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚
â”‚  â”‚                        â”‚    â”‚                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              LocalStorage (æŒä¹…åŒ–å±‚)                       â”‚ â”‚
â”‚  â”‚  - æ³•æœ¯ç¨‹åº (CompiledSpell)                               â”‚ â”‚
â”‚  â”‚  - ç¼–è¾‘å™¨UIçŠ¶æ€ (nodes, edges)                            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ä¸‰å±‚æ¶æ„æ¨¡å‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    è¡¨ç¤ºå±‚ (Presentation Layer)           â”‚
â”‚  - React Components (UI)                               â”‚
â”‚  - ReactFlow Canvas (èŠ‚ç‚¹ç¼–è¾‘å™¨)                        â”‚
â”‚  - Phaser Scenes (æ¸¸æˆåœºæ™¯)                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    é€»è¾‘å±‚ (Logic Layer)                 â”‚
â”‚  - flowToIR (ç¼–è¯‘å™¨)                                    â”‚
â”‚  - Evaluator (è§£é‡Šå™¨)                                   â”‚
â”‚  - castSpell (æ³•æœ¯æ‰§è¡Œ)                                 â”‚
â”‚  - BossStore / SkillManager (æ¸¸æˆé€»è¾‘)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ•°æ®å±‚ (Data Layer)                  â”‚
â”‚  - AST èŠ‚ç‚¹ç»“æ„                                         â”‚
â”‚  - Function Registry (å‡½æ•°è¡¨)                           â”‚
â”‚  - spellStorage (æŒä¹…åŒ–)                                â”‚
â”‚  - GameWorld State (æ¸¸æˆä¸–ç•ŒçŠ¶æ€)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## æ•°æ®æµè¯¦è§£

### 1. ç¼–è¾‘å™¨ç¼–è¯‘æµç¨‹

è¿™æ˜¯æ³•æœ¯ä»å¯è§†åŒ–èŠ‚ç‚¹å›¾è½¬æ¢ä¸ºå¯æ‰§è¡ŒASTçš„å®Œæ•´æµç¨‹ï¼š

```
ç”¨æˆ·åœ¨ç”»å¸ƒä¸Šæ‹–æ‹½èŠ‚ç‚¹å’Œè¿çº¿
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ReactFlow State                        â”‚
â”‚  nodes: Node[]  - æ‰€æœ‰èŠ‚ç‚¹               â”‚
â”‚  edges: Edge[]  - æ‰€æœ‰è¿æ¥               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“ (ç‚¹å‡» "Evaluate" æŒ‰é’®)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  flowToIR(nodes, edges)                 â”‚
â”‚  ä½ç½®: src/editor/utils/flowToIR.ts     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ 1. æ„å»ºå…¥åº¦æ˜ å°„è¡¨                  â”‚  â”‚
â”‚  â”‚    incomingEdges: Map<nodeId, Edge[]> â”‚
â”‚  â”‚                                   â”‚  â”‚
â”‚  â”‚ 2. æŸ¥æ‰¾OutputèŠ‚ç‚¹ (å¿…éœ€æœ‰1ä¸ª)      â”‚  â”‚
â”‚  â”‚                                   â”‚  â”‚
â”‚  â”‚ 3. ä»OutputèŠ‚ç‚¹é€’å½’éå†           â”‚  â”‚
â”‚  â”‚    convertNode(node) â†’ ASTNode    â”‚  â”‚
â”‚  â”‚                                   â”‚  â”‚
â”‚  â”‚ 4. è¯†åˆ«Lambdaå®šä¹‰å’Œè¿”å›å€¼          â”‚  â”‚
â”‚  â”‚    FunctionOut â†’ FunctionDefinitionâ”‚  â”‚
â”‚  â”‚                                   â”‚  â”‚
â”‚  â”‚ 5. ç‰¹æ®Šå¤„ç†ï¼š                     â”‚  â”‚
â”‚  â”‚    - å‚æ•°æ¨¡å¼è½¬æ¢ (literal-xy)    â”‚  â”‚
â”‚  â”‚    - onTriggeråŒ…è£…ä¸ºLambda        â”‚  â”‚
â”‚  â”‚    - VectorèŠ‚ç‚¹è½¬vec::create      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è¿”å›å€¼ï¼š{ ast, functions }             â”‚
â”‚  - ast: ASTNode (ä¸»è¡¨è¾¾å¼)              â”‚
â”‚  - functions: FunctionDefinition[] (ç”¨æˆ·å®šä¹‰å‡½æ•°) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Evaluator.run(ast)                     â”‚
â”‚  ä½ç½®: src/editor/ast/evaluator.ts      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ 1. æ³¨å†Œæ ¸å¿ƒåº“å‡½æ•°                  â”‚  â”‚
â”‚  â”‚    registerCoreLibrary(evaluator) â”‚  â”‚
â”‚  â”‚                                   â”‚  â”‚
â”‚  â”‚ 2. æ³¨å†Œç”¨æˆ·è‡ªå®šä¹‰å‡½æ•°              â”‚  â”‚
â”‚  â”‚    functions.forEach(registerFunction) â”‚
â”‚  â”‚                                   â”‚  â”‚
â”‚  â”‚ 3. é€’å½’æ±‚å€¼AST                    â”‚  â”‚
â”‚  â”‚    evaluate(ast, env)             â”‚  â”‚
â”‚  â”‚    â”œâ”€ Literal â†’ è¿”å›å€¼             â”‚  â”‚
â”‚  â”‚    â”œâ”€ Identifier â†’ æŸ¥è¡¨            â”‚  â”‚
â”‚  â”‚    â”œâ”€ FunctionCall â†’ è°ƒç”¨å‡½æ•°      â”‚  â”‚
â”‚  â”‚    â”œâ”€ IfExpression â†’ æ¡ä»¶åˆ†æ”¯      â”‚  â”‚
â”‚  â”‚    â””â”€ Lambda â†’ åˆ›å»ºé—­åŒ…           â”‚  â”‚
â”‚  â”‚                                   â”‚  â”‚
â”‚  â”‚ 4. ç¯å¢ƒç®¡ç† (å˜é‡ä½œç”¨åŸŸ)           â”‚  â”‚
â”‚  â”‚    Environment: Map<name, Value>  â”‚  â”‚
â”‚  â”‚                                   â”‚  â”‚
â”‚  â”‚ 5. ç¼“å­˜ä¼˜åŒ– (çº¯å‡½æ•°è®°å¿†åŒ–)         â”‚  â”‚
â”‚  â”‚    cache: Map<funcName:args, result> â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ‰§è¡Œç»“æœ: Value                        â”‚
â”‚  - number / string / boolean           â”‚
â”‚  - Value[] (åˆ—è¡¨)                       â”‚
â”‚  - FunctionValue (å‡½æ•°ä½œä¸ºå€¼)           â”‚
â”‚  - Vector2D (2Då‘é‡)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“ (ç”¨æˆ·ç‚¹å‡»ä¿å­˜)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  spellStorage.upsertSpell()             â”‚
â”‚  ä¿å­˜åˆ° localStorage                    â”‚
â”‚  {                                      â”‚
â”‚    ast: ASTNode,                        â”‚
â”‚    dependencies: FunctionDefinition[],  â”‚
â”‚    name: string,                        â”‚
â”‚    trigger: string                      â”‚
â”‚  }                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ¸¸æˆä¸­æ³•æœ¯æ‰§è¡Œæµç¨‹

```
ç©å®¶è¿›å…¥æ¸¸æˆå…³å¡
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phaser Scene (Level1-20)               â”‚
â”‚  åŠ è½½å…³å¡é…ç½®                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä» localStorage è¯»å–æ³•æœ¯                â”‚
â”‚  spellStorage.getSpells()               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Bossè§¦å‘äº‹ä»¶ (ç¤ºä¾‹: onEnemyNearby)      â”‚
â”‚  EventBus.emit('trigger', { type, eid })â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ¸¸æˆç³»ç»ŸæŸ¥æ‰¾åŒ¹é…çš„æ³•æœ¯                   â”‚
â”‚  spell.trigger === 'onEnemyNearby'      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  castSpell(world, casterEid, spell)     â”‚
â”‚  ä½ç½®: src/game/spells/castSpell.ts     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ 1. åˆ›å»ºæ–°çš„ Evaluator å®ä¾‹         â”‚  â”‚
â”‚  â”‚                                   â”‚  â”‚
â”‚  â”‚ 2. è®¾ç½®æ¸¸æˆè¿è¡Œæ—¶ä¸Šä¸‹æ–‡            â”‚  â”‚
â”‚  â”‚    setGameRuntimeContext()        â”‚  â”‚
â”‚  â”‚    - æ³¨å…¥ GameWorld å¼•ç”¨           â”‚  â”‚
â”‚  â”‚    - æ³¨å…¥æ–½æ³•è€… EID                â”‚  â”‚
â”‚  â”‚    - å¯ç”¨ game::* å‡½æ•°åº“          â”‚  â”‚
â”‚  â”‚                                   â”‚  â”‚
â”‚  â”‚ 3. æ³¨å†Œæ¸¸æˆäº¤äº’å‡½æ•°                â”‚  â”‚
â”‚  â”‚    registerFunctionSpecs(         â”‚  â”‚
â”‚  â”‚      evaluator,                   â”‚  â”‚
â”‚  â”‚      getGameFunctions()           â”‚  â”‚
â”‚  â”‚    )                              â”‚  â”‚
â”‚  â”‚                                   â”‚  â”‚
â”‚  â”‚ 4. æ³¨å†Œæ³•æœ¯ä¾èµ–å‡½æ•°                â”‚  â”‚
â”‚  â”‚    spell.dependencies.forEach(    â”‚  â”‚
â”‚  â”‚      fn => evaluator.registerFunction(fn) â”‚
â”‚  â”‚    )                              â”‚  â”‚
â”‚  â”‚                                   â”‚  â”‚
â”‚  â”‚ 5. æ‰§è¡Œæ³•æœ¯AST                    â”‚  â”‚
â”‚  â”‚    result = evaluator.run(spell.ast) â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  game::* å‡½æ•°æ‰§è¡Œ                       â”‚
â”‚  (ä¾‹å¦‚: game::fireball)                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ 1. è·å–GameWorldå¼•ç”¨               â”‚  â”‚
â”‚  â”‚                                   â”‚  â”‚
â”‚  â”‚ 2. åˆ›å»ºæ¸¸æˆå®ä½“                    â”‚  â”‚
â”‚  â”‚    - Phaser.Physics.Sprite        â”‚  â”‚
â”‚  â”‚    - ECS ç»„ä»¶                     â”‚  â”‚
â”‚  â”‚                                   â”‚  â”‚
â”‚  â”‚ 3. åº”ç”¨ç‰©ç†æ•ˆæœ                    â”‚  â”‚
â”‚  â”‚    - è®¾ç½®é€Ÿåº¦                      â”‚  â”‚
â”‚  â”‚    - ç¢°æ’æ£€æµ‹                      â”‚  â”‚
â”‚  â”‚                                   â”‚  â”‚
â”‚  â”‚ 4. æ³¨å†Œå›è°ƒ                       â”‚  â”‚
â”‚  â”‚    - onCollide â†’ ä¼¤å®³è®¡ç®—          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phaser ç‰©ç†å¼•æ“æ›´æ–°                    â”‚
â”‚  - å®ä½“ç§»åŠ¨                             â”‚
â”‚  - ç¢°æ’æ£€æµ‹                             â”‚
â”‚  - åŠ¨ç”»æ’­æ”¾                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ¸¸æˆçŠ¶æ€æ›´æ–°                            â”‚
â”‚  - Bosså—ä¼¤ (BossStore.damage())        â”‚
â”‚  - Bossæ­»äº¡ (å…³å¡èƒœåˆ©)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. èŠ‚ç‚¹ç±»å‹è½¬æ¢æ˜ å°„è¡¨

| ReactFlowèŠ‚ç‚¹ç±»å‹ | è½¬æ¢åçš„ASTç±»å‹ | å¤‡æ³¨ |
|------------------|----------------|------|
| `literal` | `Literal` | å¸¸é‡å€¼ï¼šnumber/string/boolean |
| `triggerType` | `Literal` (string) | è§¦å‘å™¨ç±»å‹ä½œä¸ºå­—ç¬¦ä¸²å­—é¢é‡ |
| `vector` | `Literal` (Vector2D) | 2Då‘é‡ {type: 'vector2d', x, y} |
| `identifier` | `Identifier` | å˜é‡æˆ–å‡½æ•°åå¼•ç”¨ |
| `dynamicFunction` | `FunctionCall` | æ ‡å‡†åº“å‡½æ•°è°ƒç”¨ |
| `customFunction` | `FunctionCall` | ç”¨æˆ·è‡ªå®šä¹‰å‡½æ•°è°ƒç”¨ |
| `applyFunc` | `FunctionCall` | å‡½æ•°åº”ç”¨ï¼ˆå‡½æ•°ä½œä¸ºå‚æ•°ï¼‰ |
| `if` | `IfExpression` | æ¡ä»¶è¡¨è¾¾å¼ï¼ˆä¸‰å…ƒæ“ä½œï¼‰ |
| `lambdaDef` (å‚æ•°handle) | `Identifier` | Lambdaå‚æ•°å¼•ç”¨ |
| `functionOut` (function handle) | `Identifier` | å‡½æ•°åå¼•ç”¨ |

---

## å…³é”®æ¨¡å—æ·±å…¥

### æ¨¡å—1: ASTå®šä¹‰ (`src/editor/ast/ast.ts`)

#### ASTèŠ‚ç‚¹ç±»å‹ï¼ˆ5ç§ï¼‰

```typescript
// 1. Literal - å­—é¢é‡
{
  type: 'Literal',
  value: number | string | boolean | Value[] | Vector2D
}
// ç¤ºä¾‹: { type: 'Literal', value: 42 }

// 2. Identifier - æ ‡è¯†ç¬¦ï¼ˆå˜é‡/å‡½æ•°åï¼‰
{
  type: 'Identifier',
  name: string
}
// ç¤ºä¾‹: { type: 'Identifier', name: 'add' }

// 3. FunctionCall - å‡½æ•°è°ƒç”¨
{
  type: 'FunctionCall',
  function: ASTNode | string,  // å‡½æ•°åæˆ–å‡½æ•°è¡¨è¾¾å¼
  args: ASTNode[]              // å‚æ•°åˆ—è¡¨
}
// ç¤ºä¾‹:
// {
//   type: 'FunctionCall',
//   function: 'add',
//   args: [
//     { type: 'Literal', value: 10 },
//     { type: 'Literal', value: 20 }
//   ]
// }

// 4. IfExpression - æ¡ä»¶è¡¨è¾¾å¼
{
  type: 'IfExpression',
  condition: ASTNode,   // æ¡ä»¶ï¼ˆå¿…é¡»ä¸ºbooleanï¼‰
  thenBranch: ASTNode,  // trueåˆ†æ”¯
  elseBranch: ASTNode   // falseåˆ†æ”¯
}
// ç¤ºä¾‹:
// if (x > 0) then x else -x
// {
//   type: 'IfExpression',
//   condition: {
//     type: 'FunctionCall',
//     function: 'gt',
//     args: [
//       { type: 'Identifier', name: 'x' },
//       { type: 'Literal', value: 0 }
//     ]
//   },
//   thenBranch: { type: 'Identifier', name: 'x' },
//   elseBranch: {
//     type: 'FunctionCall',
//     function: 'negate',
//     args: [{ type: 'Identifier', name: 'x' }]
//   }
// }

// 5. Lambda - åŒ¿åå‡½æ•°
{
  type: 'Lambda',
  params: string[],  // å‚æ•°ååˆ—è¡¨
  body: ASTNode      // å‡½æ•°ä½“ï¼ˆå•ä¸ªè¡¨è¾¾å¼ï¼‰
}
// ç¤ºä¾‹: (x, y) => x + y
// {
//   type: 'Lambda',
//   params: ['x', 'y'],
//   body: {
//     type: 'FunctionCall',
//     function: 'add',
//     args: [
//       { type: 'Identifier', name: 'x' },
//       { type: 'Identifier', name: 'y' }
//     ]
//   }
// }
```

#### å€¼ç±»å‹ç³»ç»Ÿ

```typescript
type Value =
  | number          // æ•°å­—
  | string          // å­—ç¬¦ä¸²
  | boolean         // å¸ƒå°”å€¼
  | Value[]         // åˆ—è¡¨ï¼ˆå¯åµŒå¥—ï¼‰
  | FunctionValue   // å‡½æ•°ä½œä¸ºä¸€ç­‰å…¬æ°‘
  | Vector2D        // 2Då‘é‡

// FunctionValue - å‡½æ•°å€¼ç±»å‹
interface FunctionValue {
  type: 'function',
  definition: FunctionDefinition,
  capturedEnv?: Map<string, Value>  // é—­åŒ…ï¼šæ•è·çš„ç¯å¢ƒ
}

// Vector2D - 2Då‘é‡ç±»å‹
interface Vector2D {
  type: 'vector2d',
  x: number,
  y: number
}
```

---

### æ¨¡å—2: ç¼–è¯‘å™¨ (`src/editor/utils/flowToIR.ts`)

#### æ ¸å¿ƒç®—æ³•ï¼šå›¾è½¬AST

```typescript
function flowToIR(nodes: Node[], edges: Edge[]): {
  ast: ASTNode;
  functions: FunctionDefinition[]
}
```

**ç¼–è¯‘æ­¥éª¤ï¼š**

1. **æ„å»ºé‚»æ¥è¡¨**
   ```typescript
   const incomingEdges = new Map<string, Edge[]>();
   edges.forEach(edge => {
     const list = incomingEdges.get(edge.target) || [];
     list.push(edge);
     incomingEdges.set(edge.target, list);
   });
   ```

2. **æå–å‡½æ•°å®šä¹‰**
   - æŸ¥æ‰¾æ‰€æœ‰ `FunctionOut` èŠ‚ç‚¹
   - æ¯ä¸ª FunctionOut å¯¹åº”ä¸€ä¸ªç”¨æˆ·å®šä¹‰å‡½æ•°
   - å‘åè¿½æº¯æ‰¾åˆ°å¯¹åº”çš„ `LambdaDef` èŠ‚ç‚¹
   - æå–å‚æ•°åˆ—è¡¨å’Œå‡½æ•°ä½“

3. **æ‰¾åˆ°å…¥å£ç‚¹**
   ```typescript
   const outputNode = nodes.find(n => n.type === 'output');
   if (!outputNode) {
     throw new Error('No output node found in the graph');
   }
   ```

4. **é€’å½’è½¬æ¢**
   ```typescript
   function convertNode(
     node: FlowNode,
     allNodes: Node[],
     incomingEdges: Map<string, Edge[]>,
     sourceHandle?: string
   ): ASTNode {
     switch (node.type) {
       case 'literal': return { type: 'Literal', value: node.data.value }
       case 'dynamicFunction':
         // å¤„ç†å‚æ•°æ¨¡å¼ï¼ˆliteral-xyç­‰ï¼‰
         // é€’å½’è½¬æ¢å‚æ•°
         return { type: 'FunctionCall', function: ..., args: [...] }
       // ... å…¶ä»–èŠ‚ç‚¹ç±»å‹
     }
   }
   ```

#### ç‰¹æ®Šå¤„ç†æœºåˆ¶

**1. å‚æ•°æ¨¡å¼ï¼ˆParameter Modesï¼‰**

æŸäº›å‡½æ•°æ”¯æŒå¤šç§è¾“å…¥æ¨¡å¼ï¼Œä¾‹å¦‚ä½ç½®å‚æ•°å¯ä»¥æ˜¯ï¼š
- `vector` æ¨¡å¼ï¼šæ¥æ”¶ä¸€ä¸ªVector2Då€¼
- `literal-xy` æ¨¡å¼ï¼šæ¥æ”¶ä¸¤ä¸ªæ•°å­—(x, y)ï¼Œç¼–è¯‘å™¨è‡ªåŠ¨åˆæˆ `vec::create(x, y)`

```typescript
// ç”¨æˆ·è¿æ¥äº†ä¸¤ä¸ªæ•°å­—èŠ‚ç‚¹åˆ° position å‚æ•°
if (currentMode === 'literal-xy') {
  const arg1 = convertNode(sourceNode1, ...);
  const arg2 = convertNode(sourceNode2, ...);
  // è‡ªåŠ¨ç”Ÿæˆ vec::create è°ƒç”¨
  args.push({
    type: 'FunctionCall',
    function: 'vec::create',
    args: [arg1, arg2]
  });
}
```

**2. onTriggerç‰¹æ®ŠåŒ…è£…**

`game::onTrigger` çš„ action å‚æ•°éœ€è¦å»¶è¿Ÿæ‰§è¡Œï¼Œç¼–è¯‘å™¨è‡ªåŠ¨åŒ…è£…ä¸º Lambdaï¼š

```typescript
// ç‰¹æ®Šå¤„ç† onTrigger çš„ action å‚æ•°
if (functionName === 'game::onTrigger' && paramName === 'action') {
  const actionAST = convertNode(sourceNode, ...);
  // è‡ªåŠ¨åŒ…è£…ä¸ºæ— å‚æ•° Lambda
  args.push({
    type: 'Lambda',
    params: [],      // æ— å‚æ•°
    body: actionAST  // åŸå§‹è¡¨è¾¾å¼ä½œä¸ºå‡½æ•°ä½“
  });
}
```

**3. Lambdaå‚æ•°å¼•ç”¨**

å½“è®¿é—® `LambdaDef` èŠ‚ç‚¹çš„å‚æ•°handleæ—¶ï¼Œè½¬æ¢ä¸º `Identifier`ï¼š

```typescript
case 'lambdaDef':
  if (sourceHandle && sourceHandle.startsWith('param')) {
    const paramIndex = parseInt(sourceHandle.replace('param', ''));
    const paramName = data.params?.[paramIndex] || `arg${paramIndex}`;
    return { type: 'Identifier', name: paramName };
  }
```

---

### æ¨¡å—3: è§£é‡Šå™¨ (`src/editor/ast/evaluator.ts`)

#### æ ¸å¿ƒç±»ï¼šEvaluator

```typescript
export class Evaluator {
  private functionTable: Map<string, FunctionDefinition>;
  private cache: Map<string, Value>;  // è®°å¿†åŒ–ç¼“å­˜
  private callStack: string[];        // è°ƒç”¨æ ˆï¼ˆç”¨äºé€’å½’ï¼‰
  private callStackValues: FunctionValue[];  // Lambdaè°ƒç”¨æ ˆ

  constructor() {
    // è‡ªåŠ¨æ³¨å†Œæ ¸å¿ƒåº“å‡½æ•°
    registerCoreLibrary(this);
  }
}
```

#### æ±‚å€¼ç®—æ³•

```typescript
evaluate(node: ASTNode, env: Environment): Value {
  switch (node.type) {
    case 'Literal':
      return node.value;

    case 'Identifier':
      // 1. å…ˆæŸ¥å±€éƒ¨ç¯å¢ƒï¼ˆå‚æ•°ï¼‰
      if (env.has(node.name)) {
        return env.get(node.name);
      }
      // 2. å†æŸ¥å‡½æ•°è¡¨
      const fnDef = this.functionTable.get(node.name);
      if (fnDef) {
        // è¿”å›å‡½æ•°ä½œä¸ºå€¼ï¼ˆä¸€ç­‰å‡½æ•°ï¼‰
        return {
          type: 'function',
          definition: fnDef,
          capturedEnv: new Map(env)  // æ•è·å½“å‰ç¯å¢ƒ
        };
      }
      throw new Error(`Undefined identifier: ${node.name}`);

    case 'FunctionCall':
      return this.evalFunctionCall(node, env);

    case 'IfExpression':
      const condition = this.evaluate(node.condition, env);
      // æƒ°æ€§æ±‚å€¼ï¼šåªæ‰§è¡Œé€‰ä¸­çš„åˆ†æ”¯
      return condition
        ? this.evaluate(node.thenBranch, env)
        : this.evaluate(node.elseBranch, env);

    case 'Lambda':
      // åˆ›å»ºé—­åŒ…ï¼šæ•è·å½“å‰ç¯å¢ƒ
      return {
        type: 'function',
        definition: {
          name: '<lambda>',
          params: node.params,
          body: node.body
        },
        capturedEnv: new Map(env)
      };
  }
}
```

#### å‡½æ•°è°ƒç”¨è¯¦è§£

```typescript
evalFunctionCall(node: FunctionCall, env: Environment): Value {
  // 1. è§£æå‡½æ•°å®šä¹‰
  let fnDef: FunctionDefinition;
  if (typeof node.function === 'string') {
    // ç‰¹æ®Šå¤„ç†é€’å½’ï¼šstd::fn::this
    if (node.function === 'std::fn::this') {
      fnDef = this.callStack[this.callStack.length - 1];
    } else {
      fnDef = this.functionTable.get(node.function);
    }
  } else {
    // é«˜é˜¶å‡½æ•°ï¼šå‡½æ•°ä½œä¸ºè¡¨è¾¾å¼
    const funcValue = this.evaluate(node.function, env);
    fnDef = funcValue.definition;
  }

  // 2. æ±‚å€¼å‚æ•°
  const argValues = node.args.map(arg => this.evaluate(arg, env));

  // 3. æŸ¯é‡ŒåŒ–ï¼ˆéƒ¨åˆ†åº”ç”¨ï¼‰
  if (fnDef.params.length > 0 && argValues.length < fnDef.params.length) {
    // å‚æ•°ä¸è¶³ï¼šè¿”å›éƒ¨åˆ†åº”ç”¨çš„æ–°å‡½æ•°
    const partialEnv = new Map(funcValue?.capturedEnv || new Map());
    boundParams.forEach((param, i) => {
      partialEnv.set(param, argValues[i]);
    });
    return {
      type: 'function',
      definition: {
        name: `<partial-${fnName}>`,
        params: remainingParams,
        body: fnDef.body
      },
      capturedEnv: partialEnv
    };
  }

  // 4. æ£€æŸ¥å‚æ•°æ•°é‡
  if (argValues.length > fnDef.params.length) {
    throw new Error(`Too many arguments`);
  }

  // 5. åŸç”Ÿå‡½æ•°ç›´æ¥æ‰§è¡Œ
  if (fnDef.__native) {
    return fnDef.__native(...argValues);
  }

  // 6. æ£€æŸ¥ç¼“å­˜ï¼ˆçº¯å‡½æ•°ä¼˜åŒ–ï¼‰
  const cacheKey = `${fnName}:${JSON.stringify(argValues)}`;
  if (this.cache.has(cacheKey)) {
    return this.cache.get(cacheKey);
  }

  // 7. åˆ›å»ºè°ƒç”¨ç¯å¢ƒ
  const callEnv = new Map(funcValue?.capturedEnv || new Map());
  fnDef.params.forEach((param, i) => {
    callEnv.set(param, argValues[i]);
  });

  // 8. æ‰§è¡Œå‡½æ•°ä½“
  this.callStack.push(fnName);
  try {
    const result = this.evaluate(fnDef.body, callEnv);
    this.cache.set(cacheKey, result);  // ç¼“å­˜ç»“æœ
    return result;
  } finally {
    this.callStack.pop();
  }
}
```

#### å‡½æ•°å¼ç‰¹æ€§å®ç°

**1. ä¸€ç­‰å‡½æ•°ï¼ˆFirst-class Functionsï¼‰**
- Lambdaå¯ä»¥ä½œä¸ºå€¼ä¼ é€’
- å‡½æ•°å¯ä»¥ä½œä¸ºå‚æ•°å’Œè¿”å›å€¼
- `Identifier` æŸ¥æ‰¾å‡½æ•°æ—¶è¿”å› `FunctionValue`

**2. é—­åŒ…ï¼ˆClosuresï¼‰**
```typescript
// Lambdaåˆ›å»ºæ—¶æ•è·ç¯å¢ƒ
evalLambda(node: Lambda, env: Environment): FunctionValue {
  return {
    type: 'function',
    definition: { ... },
    capturedEnv: new Map(env)  // å¤åˆ¶å½“å‰ç¯å¢ƒ
  };
}

// å‡½æ•°è°ƒç”¨æ—¶ä½¿ç”¨æ•è·çš„ç¯å¢ƒ
const callEnv = new Map(funcValue.capturedEnv);
```

**3. æŸ¯é‡ŒåŒ–ï¼ˆCurryingï¼‰/ éƒ¨åˆ†åº”ç”¨**
```typescript
// å‚æ•°ä¸è¶³æ—¶è‡ªåŠ¨æŸ¯é‡ŒåŒ–
if (argValues.length < fnDef.params.length) {
  return createPartialFunction(fnDef, argValues);
}
```

**4. é€’å½’ï¼ˆRecursionï¼‰**
```typescript
// ä½¿ç”¨ std::fn::this å¼•ç”¨å½“å‰å‡½æ•°
if (node.function === 'std::fn::this') {
  fnDef = this.callStack[this.callStack.length - 1];
}
```

**5. æƒ°æ€§æ±‚å€¼ï¼ˆLazy Evaluationï¼‰**
```typescript
// Ifè¡¨è¾¾å¼åªæ±‚å€¼é€‰ä¸­çš„åˆ†æ”¯
return condition
  ? this.evaluate(node.thenBranch, env)
  : this.evaluate(node.elseBranch, env);
```

---

### æ¨¡å—4: å‡½æ•°åº“ (`src/editor/library/`)

#### å‡½æ•°åº“ç»„ç»‡ç»“æ„

```
library/
â”œâ”€â”€ types.ts          # FunctionSpec æ¥å£å®šä¹‰
â”œâ”€â”€ core.ts           # èšåˆå¯¼å‡ºæ‰€æœ‰å‡½æ•°
â”œâ”€â”€ math.ts           # æ•°å­¦å‡½æ•° (15ä¸ª)
â”œâ”€â”€ logic.ts          # é€»è¾‘å‡½æ•° (8ä¸ª)
â”œâ”€â”€ list.ts           # åˆ—è¡¨å‡½æ•° (20+)
â”œâ”€â”€ vector.ts         # å‘é‡å‡½æ•° (10+)
â”œâ”€â”€ fn.ts             # é«˜é˜¶å‡½æ•° (5ä¸ª)
â”œâ”€â”€ string.ts         # å­—ç¬¦ä¸²å‡½æ•° (5ä¸ª)
â””â”€â”€ game.ts           # æ¸¸æˆäº¤äº’å‡½æ•° (10+)
```

#### å‡½æ•°è§„èŒƒï¼ˆFunctionSpecï¼‰

```typescript
interface FunctionSpec {
  fullName: string;        // å®Œæ•´å‡½æ•°åï¼ˆå¸¦å‘½åç©ºé—´ï¼‰
  params: string[];        // å‚æ•°ååˆ—è¡¨
  fn: (...args: Value[]) => Value;  // åŸç”Ÿå®ç°
  ui?: FunctionUiMeta;     // UIå…ƒä¿¡æ¯ï¼ˆåˆ†ç±»ã€æè¿°ç­‰ï¼‰
  parameterModes?: Record<string, ParameterModeOption[]>;  // å‚æ•°æ¨¡å¼
}

// ç¤ºä¾‹ï¼šåŠ æ³•å‡½æ•°
{
  fullName: 'math::add',
  params: ['a', 'b'],
  fn: (a, b) => {
    if (typeof a !== 'number' || typeof b !== 'number') {
      throw new Error('add expects two numbers');
    }
    return a + b;
  },
  ui: {
    category: 'math',
    label: 'Add',
    description: 'Add two numbers'
  }
}
```

#### æ ¸å¿ƒå‡½æ•°åº“æ¸…å•

**Math (æ•°å­¦) - `math.ts`**
```
add, subtract, multiply, divide,    // åŸºç¡€è¿ç®—
negate, abs, mod, power,            // ä¸€å…ƒ/äºŒå…ƒ
max, min, floor, ceil, round,       // æ•°å€¼å¤„ç†
sqrt, random                        // ç‰¹æ®Šå‡½æ•°
```

**Logic (é€»è¾‘) - `logic.ts`**
```
and, or, not,                       // å¸ƒå°”é€»è¾‘
gt, lt, gte, lte, eq               // æ¯”è¾ƒè¿ç®—
```

**List (åˆ—è¡¨) - `list.ts`**
```
cons, head, tail, empty,            // Lispé£æ ¼
map, filter, reduce,                // é«˜é˜¶å‡½æ•°
range, length, nth,                 // åˆ—è¡¨æ“ä½œ
append, reverse, take, drop         // åˆ—è¡¨å¤„ç†
```

**Vector (å‘é‡) - `vector.ts`**
```
vec::create,                        // åˆ›å»ºå‘é‡ (x, y) â†’ Vector2D
vec::add, vec::subtract,            // å‘é‡è¿ç®—
vec::multiply, vec::divide,         // æ ‡é‡ä¹˜é™¤
vec::normalize, vec::length,        // å‘é‡è®¡ç®—
vec::dot, vec::distance             // å‘é‡å‡ ä½•
```

**Function (å‡½æ•°æ“ä½œ) - `fn.ts`**
```
fn::apply,                          // åº”ç”¨å‡½æ•°åˆ°å‚æ•°åˆ—è¡¨
fn::partial,                        // éƒ¨åˆ†åº”ç”¨
fn::compose                         // å‡½æ•°ç»„åˆ
```

**String (å­—ç¬¦ä¸²) - `string.ts`**
```
str::concat,                        // å­—ç¬¦ä¸²è¿æ¥
str::substring,                     // å­ä¸²æå–
str::length,                        // é•¿åº¦
str::toUpper, str::toLower         // å¤§å°å†™è½¬æ¢
```

**Game (æ¸¸æˆäº¤äº’) - `game.ts`**
```
game::onTrigger,                    // æ³¨å†Œè§¦å‘å™¨
game::fireball,                     // å‘å°„ç«çƒ
game::heal,                         // æ²»ç–—
game::damage,                       // é€ æˆä¼¤å®³
game::getPosition,                  // è·å–å®ä½“ä½ç½®
game::getVelocity,                  // è·å–å®ä½“é€Ÿåº¦
game::setVelocity                   // è®¾ç½®å®ä½“é€Ÿåº¦
```

#### å‡½æ•°æ³¨å†Œæµç¨‹

```typescript
// 1. åœ¨ Evaluator æ„é€ å‡½æ•°ä¸­è‡ªåŠ¨æ³¨å†Œ
constructor() {
  registerCoreLibrary(this);  // æ³¨å†Œæ ¸å¿ƒåº“
}

// 2. registerCoreLibrary å®ç°
export function registerCoreLibrary(evaluator: Evaluator): void {
  coreLibraryFunctions.forEach(spec => {
    evaluator.registerFunction({
      fullName: spec.fullName,
      params: spec.params,
      fn: spec.fn,
      ui: spec.ui,
      parameterModes: spec.parameterModes
    });
  });
}

// 3. æ¸¸æˆå‡½æ•°æ³¨å†Œï¼ˆè¿è¡Œæ—¶ï¼‰
// åœ¨ castSpell ä¸­åŠ¨æ€æ³¨å†Œ
setGameRuntimeContext(evaluator, world, casterEid, spell);
registerFunctionSpecs(evaluator, getGameFunctions());
```

---

### æ¨¡å—5: æ¸¸æˆç³»ç»Ÿ (`src/game/`)

#### Phaseræ¸¸æˆæ¶æ„

```
Phaser.Game
â”œâ”€â”€ Scene: MainInterface        # ä¸»èœå•
â”œâ”€â”€ Scene: LevelSelectInterface # å…³å¡é€‰æ‹©
â”œâ”€â”€ Scene: SettingsInterface    # è®¾ç½®
â”œâ”€â”€ Scene: PauseInterface       # æš‚åœèœå•
â”œâ”€â”€ Scene: VictoryInterface     # èƒœåˆ©ç•Œé¢
â””â”€â”€ Scenes: Level1-20           # æ¸¸æˆå…³å¡
    â”œâ”€â”€ preload()               # åŠ è½½èµ„æº
    â”œâ”€â”€ create()                # åˆå§‹åŒ–åœºæ™¯
    â”œâ”€â”€ update()                # æ¯å¸§æ›´æ–°
    â””â”€â”€ Bossç³»ç»Ÿ
        â”œâ”€â”€ BossStore           # çŠ¶æ€ç®¡ç†
        â”œâ”€â”€ SkillManager        # æŠ€èƒ½ç®¡ç†
        â””â”€â”€ EventBus            # äº‹ä»¶æ€»çº¿
```

#### Bossç³»ç»Ÿè¯¦è§£

**æ¶æ„ï¼šå‘å¸ƒ-è®¢é˜…æ¨¡å¼ + æœ‰é™çŠ¶æ€æœº**

```
BossStore (çŠ¶æ€ç®¡ç†ä¸­å¿ƒ)
â”œâ”€â”€ state: BossState
â”‚   â”œâ”€â”€ phase: 1 | 2 | 3
â”‚   â”œâ”€â”€ health: number
â”‚   â”œâ”€â”€ maxHealth: number
â”‚   â”œâ”€â”€ position: Vector2D
â”‚   â””â”€â”€ isInvulnerable: boolean
â”‚
â”œâ”€â”€ subscribers: Array<(state) => void>
â”‚
â””â”€â”€ methods:
    â”œâ”€â”€ setState(updates)       # æ›´æ–°çŠ¶æ€å¹¶é€šçŸ¥è®¢é˜…è€…
    â”œâ”€â”€ subscribe(listener)     # è®¢é˜…çŠ¶æ€å˜åŒ–
    â””â”€â”€ damage(amount)          # é€ æˆä¼¤å®³

EventBus (äº‹ä»¶æ€»çº¿)
â”œâ”€â”€ events: Map<eventName, handlers[]>
â””â”€â”€ methods:
    â”œâ”€â”€ on(event, handler)      # æ³¨å†Œäº‹ä»¶ç›‘å¬
    â”œâ”€â”€ emit(event, data)       # è§¦å‘äº‹ä»¶
    â””â”€â”€ off(event, handler)     # å–æ¶ˆç›‘å¬

SkillManager (æŠ€èƒ½ç®¡ç†å™¨)
â”œâ”€â”€ skills: BossSkill[]
â”‚   â”œâ”€â”€ Phase1: [LinearCut, RotatingShield, GeometricBlade, FragmentDecoy]
â”‚   â”œâ”€â”€ Phase2: [ZigzagRush, ShadowEcho, CloakTracking, RedMoonSlash, SpaceCollapse]
â”‚   â””â”€â”€ Phase3: [TripleIllusion, FullScreenPurge, FinalCollapse]
â”‚
â”œâ”€â”€ activeSkill: BossSkill | null
â”‚
â””â”€â”€ methods:
    â”œâ”€â”€ selectSkill(phase)      # æ ¹æ®é˜¶æ®µé€‰æ‹©æŠ€èƒ½
    â”œâ”€â”€ executeSkill()          # æ‰§è¡Œå½“å‰æŠ€èƒ½
    â””â”€â”€ updateSkills(delta)     # æ›´æ–°æŠ€èƒ½çŠ¶æ€
```

#### ECSç»„ä»¶ç³»ç»Ÿï¼ˆbitecsï¼‰

```typescript
// ç»„ä»¶å®šä¹‰
const Health = defineComponent({ current: Types.i32, max: Types.i32 });
const Motion = defineComponent({ vx: Types.f32, vy: Types.f32 });
const Fireball = defineComponent({ damage: Types.i32, ownerId: Types.eid });

// ç³»ç»Ÿç¤ºä¾‹ï¼šç§»åŠ¨ç³»ç»Ÿ
function movementSystem(world: World) {
  const entities = motionQuery(world);
  for (let i = 0; i < entities.length; i++) {
    const eid = entities[i];
    const sprite = spriteMap.get(eid);
    sprite.x += Motion.vx[eid] * delta;
    sprite.y += Motion.vy[eid] * delta;
  }
}
```

#### æ³•æœ¯æ–½æ”¾é›†æˆ

```typescript
// æ¸¸æˆåœºæ™¯ä¸­æ³¨å†Œæ³•æœ¯è§¦å‘å™¨
create() {
  // åŠ è½½æ³•æœ¯
  const spells = getSpells();

  // ç›‘å¬Bossäº‹ä»¶
  EventBus.on('enemyNearby', (data) => {
    const spell = spells.find(s => s.trigger === 'onEnemyNearby');
    if (spell) {
      castSpell(this.world, playerEid, spell);
    }
  });
}
```

---

## æ–‡ä»¶ç»“æ„ä¸èŒè´£

### å…³é”®æ–‡ä»¶ä¼˜å…ˆçº§ï¼ˆæŒ‰è°ƒè¯•/æ‰©å±•é‡è¦æ€§æ’åºï¼‰

#### ğŸ”´ æ ¸å¿ƒç¼–è¯‘å™¨å’Œè§£é‡Šå™¨ï¼ˆå¿…è¯»ï¼‰

| æ–‡ä»¶è·¯å¾„ | è¡Œæ•° | èŒè´£ | ä½•æ—¶é˜…è¯» |
|---------|------|------|---------|
| `src/editor/ast/ast.ts` | 104 | **ASTèŠ‚ç‚¹ç±»å‹å®šä¹‰** - 5ç§èŠ‚ç‚¹ç±»å‹ã€Valueç±»å‹ç³»ç»Ÿã€FunctionValueç»“æ„ | BUGå®šä½ï¼šç±»å‹é”™è¯¯ã€ASTç»“æ„é—®é¢˜ |
| `src/editor/ast/evaluator.ts` | 463 | **è§£é‡Šå™¨æ ¸å¿ƒ** - é€’å½’æ±‚å€¼ã€ç¯å¢ƒç®¡ç†ã€æŸ¯é‡ŒåŒ–ã€é—­åŒ…ã€é€’å½’ã€ç¼“å­˜ | BUGå®šä½ï¼šæ‰§è¡Œé”™è¯¯ã€é€’å½’é—®é¢˜ã€é—­åŒ…é—®é¢˜ |
| `src/editor/utils/flowToIR.ts` | 458 | **ç¼–è¯‘å™¨æ ¸å¿ƒ** - React Flowå›¾è½¬ASTã€å‚æ•°æ¨¡å¼å¤„ç†ã€Lambdaæå– | BUGå®šä½ï¼šç¼–è¯‘é”™è¯¯ã€èŠ‚ç‚¹è½¬æ¢é—®é¢˜ |

#### ğŸŸ  å‡½æ•°åº“ï¼ˆæ‰©å±•å¿…è¯»ï¼‰

| æ–‡ä»¶è·¯å¾„ | è¡Œæ•° | èŒè´£ | ä½•æ—¶é˜…è¯» |
|---------|------|------|---------|
| `src/editor/library/types.ts` | ~100 | **å‡½æ•°è§„èŒƒå®šä¹‰** - FunctionSpecæ¥å£ã€å‚æ•°æ¨¡å¼ã€UIå…ƒä¿¡æ¯ | æ‰©å±•ï¼šæ·»åŠ æ–°å‡½æ•° |
| `src/editor/library/core.ts` | 19 | **å‡½æ•°åº“èšåˆ** - å¯¼å‡ºæ‰€æœ‰å‡½æ•°æ¨¡å— | æ‰©å±•ï¼šæ³¨å†Œæ–°å‡½æ•°æ¨¡å— |
| `src/editor/library/math.ts` | ~200 | æ•°å­¦å‡½æ•°å®ç° | æ‰©å±•ï¼šæ·»åŠ æ•°å­¦å‡½æ•° |
| `src/editor/library/game.ts` | ~300 | **æ¸¸æˆäº¤äº’å‡½æ•°** - ä¸Phaserå¼•æ“é€šä¿¡ | BUGå®šä½ï¼šæ³•æœ¯åœ¨æ¸¸æˆä¸­æ‰§è¡Œé—®é¢˜ |

#### ğŸŸ¡ UIç»„ä»¶ï¼ˆç•Œé¢ç›¸å…³ï¼‰

| æ–‡ä»¶è·¯å¾„ | è¡Œæ•° | èŒè´£ | ä½•æ—¶é˜…è¯» |
|---------|------|------|---------|
| `src/editor/components/FunctionalEditor.tsx` | ~600 | **ç¼–è¾‘å™¨ä¸»ç»„ä»¶** - ReactFlowé…ç½®ã€èŠ‚ç‚¹ç®¡ç†ã€æ±‚å€¼è§¦å‘ | BUGå®šä½ï¼šUIé—®é¢˜ã€ç¼–è¾‘å™¨è¡Œä¸º |
| `src/editor/components/nodes/DynamicFunctionNode.tsx` | ~200 | **åŠ¨æ€å‡½æ•°èŠ‚ç‚¹** - å‚æ•°æ¨¡å¼åˆ‡æ¢ã€åŠ¨æ€handleç”Ÿæˆ | æ‰©å±•ï¼šæ·»åŠ æ–°çš„å‚æ•°æ¨¡å¼ |
| `src/editor/components/nodes/LambdaDefNode.tsx` | ~150 | **Lambdaå®šä¹‰èŠ‚ç‚¹** - å‚æ•°ç®¡ç†ã€å‡½æ•°å‘½å | BUGå®šä½ï¼šLambdaç›¸å…³é—®é¢˜ |
| `src/editor/components/ASTVisualizer.tsx` | ~100 | ASTå¯è§†åŒ–ï¼ˆMermaidå›¾ï¼‰ | è°ƒè¯•ï¼šæŸ¥çœ‹ASTç»“æ„ |

#### ğŸŸ¢ æ¸¸æˆç³»ç»Ÿï¼ˆæ¸¸æˆç›¸å…³ï¼‰

| æ–‡ä»¶è·¯å¾„ | è¡Œæ•° | èŒè´£ | ä½•æ—¶é˜…è¯» |
|---------|------|------|---------|
| `src/game/Game.tsx` | ~200 | **Phaseræ¸¸æˆä¸»å®¹å™¨** - åœºæ™¯é…ç½®ã€ç¼–è¾‘å™¨é›†æˆ | BUGå®šä½ï¼šæ¸¸æˆåˆå§‹åŒ–é—®é¢˜ |
| `src/game/spells/castSpell.ts` | 34 | **æ³•æœ¯æ–½æ”¾å…¥å£** - åˆ›å»ºEvaluatorã€æ³¨å†Œæ¸¸æˆå‡½æ•°ã€æ‰§è¡ŒAST | BUGå®šä½ï¼šæ³•æœ¯æ‰§è¡Œé—®é¢˜ |
| `src/game/boss/core/BossStore.ts` | ~150 | BossçŠ¶æ€ç®¡ç† | BUGå®šä½ï¼šBossè¡Œä¸ºé—®é¢˜ |
| `src/game/boss/core/EventBus.ts` | ~100 | æ¸¸æˆäº‹ä»¶ç³»ç»Ÿ | æ‰©å±•ï¼šæ·»åŠ æ–°äº‹ä»¶ç±»å‹ |
| `src/game/scenes/levels/Level*.ts` | ~300 | æ¸¸æˆå…³å¡åœºæ™¯ | æ‰©å±•ï¼šåˆ›å»ºæ–°å…³å¡ |

#### ğŸ”µ å·¥å…·å’Œå­˜å‚¨

| æ–‡ä»¶è·¯å¾„ | è¡Œæ•° | èŒè´£ | ä½•æ—¶é˜…è¯» |
|---------|------|------|---------|
| `src/editor/utils/spellStorage.ts` | ~100 | **æ³•æœ¯æŒä¹…åŒ–** - localStorageå­˜å– | BUGå®šä½ï¼šä¿å­˜/åŠ è½½é—®é¢˜ |
| `src/editor/utils/functionRegistry.ts` | ~150 | å‡½æ•°æ³¨å†Œç³»ç»Ÿ | æ‰©å±•ï¼šç†è§£å‡½æ•°æ³¨å†Œæœºåˆ¶ |
| `src/editor/utils/astToMermaid.ts` | ~150 | ASTè½¬Mermaidå›¾è¡¨ | æ‰©å±•ï¼šæ”¹è¿›å¯è§†åŒ– |
| `src/main.tsx` | 45 | **åº”ç”¨å…¥å£** - è·¯ç”±åˆ†å‘ | BUGå®šä½ï¼šè·¯ç”±é—®é¢˜ |

### æ¨¡å—ä¾èµ–å…³ç³»å›¾

```
main.tsx (å…¥å£)
â”‚
â”œâ”€ Game.tsx (æ¸¸æˆ)
â”‚  â”‚
â”‚  â”œâ”€ Phaser.Game
â”‚  â”‚  â”œâ”€ Level1-20 (å…³å¡)
â”‚  â”‚  â”‚  â””â”€ BossStore + SkillManager
â”‚  â”‚  â””â”€ MainInterface / LevelSelectInterface
â”‚  â”‚
â”‚  â””â”€ castSpell() â”€â”€â”€â”€â”€â”€â”€â”
â”‚     â””â”€ Evaluator       â”‚  (æ¸¸æˆæ‰§è¡Œæ³•æœ¯)
â”‚                        â”‚
â””â”€ Editor.tsx (ç¼–è¾‘å™¨)   â”‚
   â”‚                     â”‚
   â””â”€ FunctionalEditor   â”‚
      â”‚                  â”‚
      â”œâ”€ ReactFlow (ç”»å¸ƒ) â”‚
      â”‚  â””â”€ 11ç§èŠ‚ç‚¹ç»„ä»¶  â”‚
      â”‚                  â”‚
      â”œâ”€ flowToIR â”€â”€â”€â”€â”€â”€â”€â”¤  (ç¼–è¯‘)
      â”‚  â””â”€ AST          â”‚
      â”‚                  â”‚
      â””â”€ Evaluator â”€â”€â”€â”€â”€â”€â”˜  (ç¼–è¾‘å™¨é¢„è§ˆæ‰§è¡Œ)
         â”‚
         â””â”€ FunctionLibrary
            â”œâ”€ math.ts
            â”œâ”€ logic.ts
            â”œâ”€ list.ts
            â”œâ”€ vector.ts
            â”œâ”€ fn.ts
            â”œâ”€ string.ts
            â””â”€ game.ts
```

---

## è°ƒè¯•ä¸BUGå®šä½æŒ‡å—

### é—®é¢˜åˆ†ç±»ä¸å®šä½æµç¨‹

#### é—®é¢˜1: ç¼–è¯‘é”™è¯¯ï¼ˆflowToIRå¤±è´¥ï¼‰

**ç—‡çŠ¶ï¼š**
- ç‚¹å‡» "Evaluate" æŒ‰é’®åæŠ›å‡ºå¼‚å¸¸
- é”™è¯¯ä¿¡æ¯ç±»ä¼¼ï¼š"No output node found" / "Source node not found"

**å®šä½æ­¥éª¤ï¼š**

1. **æ£€æŸ¥èŠ‚ç‚¹è¿æ¥**
   ```typescript
   // åœ¨ FunctionalEditor.tsx çš„ onEvaluate å¤„æ·»åŠ æ–­ç‚¹
   const handleEvaluate = () => {
     console.log('Current nodes:', nodes);
     console.log('Current edges:', edges);
     const { ast, functions } = flowToIR(nodes, edges);
   }
   ```

2. **éªŒè¯å¿…éœ€èŠ‚ç‚¹**
   - å¿…é¡»æœ‰1ä¸ª `Output` èŠ‚ç‚¹
   - Output èŠ‚ç‚¹å¿…é¡»æœ‰è¾“å…¥è¿æ¥
   - Lambdaå‡½æ•°å¿…é¡»æœ‰å¯¹åº”çš„ `FunctionOut` èŠ‚ç‚¹

3. **è¿½è¸ªç¼–è¯‘è¿‡ç¨‹**
   ```typescript
   // åœ¨ flowToIR.ts çš„ convertNode ä¸­æ·»åŠ æ—¥å¿—
   function convertNode(node, allNodes, incomingEdges, sourceHandle) {
     console.log(`Converting node: ${node.id} (${node.type})`);
     console.log(`Source handle: ${sourceHandle}`);
     // ... è½¬æ¢é€»è¾‘
   }
   ```

4. **å¸¸è§é”™è¯¯åŸå› **
   - **ç¼ºå°‘OutputèŠ‚ç‚¹**ï¼šæ¯ä¸ªå›¾å¿…é¡»æœ‰ä¸”ä»…æœ‰1ä¸ªOutput
   - **æ‚¬ç©ºèŠ‚ç‚¹**ï¼šèŠ‚ç‚¹æ²¡æœ‰è¿æ¥åˆ°Outputï¼ˆå¯ä»¥å­˜åœ¨ï¼Œä½†ä¸ä¼šè¢«ç¼–è¯‘ï¼‰
   - **Lambdaå‚æ•°å¼•ç”¨é”™è¯¯**ï¼š`LambdaDef` çš„å‚æ•°handleå‘½åä¸åŒ¹é…
   - **å‚æ•°æ¨¡å¼é…ç½®é”™è¯¯**ï¼š`literal-xy` æ¨¡å¼éœ€è¦è¿æ¥2ä¸ªè¾¹ï¼Œä½†åªè¿æ¥äº†1ä¸ª

**å¿«é€Ÿä¿®å¤ï¼š**
```typescript
// æ£€æŸ¥å›¾çš„å®Œæ•´æ€§
function validateGraph(nodes: Node[], edges: Edge[]): string[] {
  const errors: string[] = [];

  const outputNodes = nodes.filter(n => n.type === 'output');
  if (outputNodes.length === 0) {
    errors.push('No output node found');
  }
  if (outputNodes.length > 1) {
    errors.push('Multiple output nodes found');
  }

  // æ£€æŸ¥Outputæ˜¯å¦æœ‰è¾“å…¥
  const outputEdges = edges.filter(e => e.target === outputNodes[0]?.id);
  if (outputEdges.length === 0) {
    errors.push('Output node has no input');
  }

  return errors;
}
```

---

#### é—®é¢˜2: æ‰§è¡Œé”™è¯¯ï¼ˆEvaluatorå¤±è´¥ï¼‰

**ç—‡çŠ¶ï¼š**
- ç¼–è¯‘æˆåŠŸï¼Œä½†æ‰§è¡Œæ—¶æŠ›å‡ºå¼‚å¸¸
- é”™è¯¯ä¿¡æ¯ç±»ä¼¼ï¼š"Undefined identifier" / "Type mismatch" / "Function not found"

**å®šä½æ­¥éª¤ï¼š**

1. **æ£€æŸ¥ASTç»“æ„**
   ```typescript
   // åœ¨ FunctionalEditor.tsx ä¸­æ‰“å°AST
   const { ast, functions } = flowToIR(nodes, edges);
   console.log('Generated AST:', JSON.stringify(ast, null, 2));
   console.log('Functions:', functions);
   ```

2. **è¿½è¸ªæ±‚å€¼è¿‡ç¨‹**
   ```typescript
   // åœ¨ evaluator.ts çš„ evaluate æ–¹æ³•å¼€å¤´æ·»åŠ 
   evaluate(node: ASTNode, env: Environment): Value {
     console.log(`Evaluating ${node.type}`, node);
     console.log(`Environment:`, Array.from(env.entries()));
     // ... æ±‚å€¼é€»è¾‘
   }
   ```

3. **æ£€æŸ¥ç¯å¢ƒï¼ˆå˜é‡ä½œç”¨åŸŸï¼‰**
   ```typescript
   // åœ¨ evalFunctionCall ä¸­æ‰“å°è°ƒç”¨ç¯å¢ƒ
   const callEnv = new Map(funcValue?.capturedEnv || new Map());
   fnDef.params.forEach((param, i) => {
     callEnv.set(param, argValues[i]);
     console.log(`Binding ${param} = ${argValues[i]}`);
   });
   ```

4. **å¸¸è§é”™è¯¯åŸå› **
   - **æœªå®šä¹‰æ ‡è¯†ç¬¦**ï¼šå˜é‡åæ‹¼å†™é”™è¯¯æˆ–å‡½æ•°æœªæ³¨å†Œ
   - **ç±»å‹ä¸åŒ¹é…**ï¼šä¼ é€’äº†é”™è¯¯ç±»å‹çš„å‚æ•°ï¼ˆå¦‚å‘æ•°å­¦å‡½æ•°ä¼ é€’å­—ç¬¦ä¸²ï¼‰
   - **å‚æ•°æ•°é‡é”™è¯¯**ï¼šå‡½æ•°è°ƒç”¨çš„å‚æ•°æ•°é‡ä¸åŒ¹é…
   - **é—­åŒ…ç¯å¢ƒä¸¢å¤±**ï¼šLambdaçš„ `capturedEnv` æ²¡æœ‰æ­£ç¡®è®¾ç½®

**è°ƒè¯•æŠ€å·§ï¼š**

ä½¿ç”¨ASTå¯è§†åŒ–å·¥å…·æŸ¥çœ‹ç»“æ„ï¼š
```typescript
// åœ¨ç¼–è¾‘å™¨å³ä¾§æŸ¥çœ‹ ASTVisualizer ç»„ä»¶ç”Ÿæˆçš„Mermaidå›¾
// éªŒè¯ASTç»“æ„æ˜¯å¦ç¬¦åˆé¢„æœŸ
```

---

#### é—®é¢˜3: æ¸¸æˆä¸­æ³•æœ¯ä¸æ‰§è¡Œ

**ç—‡çŠ¶ï¼š**
- ç¼–è¾‘å™¨ä¸­æµ‹è¯•æ­£å¸¸ï¼Œä½†æ¸¸æˆä¸­æ³•æœ¯æ²¡æœ‰æ•ˆæœ
- æ§åˆ¶å°æ²¡æœ‰é”™è¯¯ä¿¡æ¯ï¼Œæˆ–è€…æ˜¾ç¤º "Spell not found"

**å®šä½æ­¥éª¤ï¼š**

1. **æ£€æŸ¥æ³•æœ¯ä¿å­˜**
   ```typescript
   // åœ¨æµè§ˆå™¨æ§åˆ¶å°æ‰§è¡Œ
   console.log(localStorage.getItem('spells'));
   ```

2. **æ£€æŸ¥è§¦å‘å™¨åŒ¹é…**
   ```typescript
   // åœ¨æ¸¸æˆåœºæ™¯ä¸­æ·»åŠ æ—¥å¿—
   EventBus.emit('trigger', { type: 'onEnemyNearby', eid: enemyEid });

   // æ£€æŸ¥æ³•æœ¯æ˜¯å¦åŒ¹é…
   const spell = spells.find(s => s.trigger === 'onEnemyNearby');
   console.log('Found spell:', spell);
   ```

3. **è¿½è¸ªcastSpellæ‰§è¡Œ**
   ```typescript
   // castSpell.ts å·²æœ‰è¯¦ç»†æ—¥å¿—
   // æ£€æŸ¥æ§åˆ¶å°è¾“å‡ºï¼š
   // [castSpell] Starting spell cast
   // [castSpell] casterEid: ...
   // [castSpell] spell.ast: ...
   ```

4. **æ£€æŸ¥æ¸¸æˆå‡½æ•°æ³¨å†Œ**
   ```typescript
   // åœ¨ castSpell ä¸­éªŒè¯å‡½æ•°è¡¨
   console.log('Registered functions:', evaluator.getFunctionNames());
   // åº”è¯¥åŒ…å« game::fireball, game::damage ç­‰
   ```

5. **å¸¸è§é”™è¯¯åŸå› **
   - **è§¦å‘å™¨ç±»å‹ä¸åŒ¹é…**ï¼šæ³•æœ¯çš„ trigger ä¸äº‹ä»¶çš„ type ä¸ä¸€è‡´
   - **æ¸¸æˆå‡½æ•°æœªæ³¨å†Œ**ï¼š`setGameRuntimeContext` æˆ– `registerFunctionSpecs` æœªè°ƒç”¨
   - **ä¾èµ–å‡½æ•°ç¼ºå¤±**ï¼šç”¨æˆ·è‡ªå®šä¹‰å‡½æ•°æ²¡æœ‰ä¿å­˜åˆ° `spell.dependencies`
   - **GameWorldå¼•ç”¨ä¸¢å¤±**ï¼šgame::* å‡½æ•°å†…éƒ¨çš„ `getGameWorld()` è¿”å› null

**å¿«é€Ÿä¿®å¤ï¼š**

```typescript
// åœ¨å…³å¡åœºæ™¯çš„ create() ä¸­æ·»åŠ æµ‹è¯•æ³•æœ¯
create() {
  // æ‰‹åŠ¨è§¦å‘æµ‹è¯•
  setTimeout(() => {
    const testSpell = {
      ast: {
        type: 'FunctionCall',
        function: 'game::fireball',
        args: [
          { type: 'Literal', value: { type: 'vector2d', x: 1, y: 0 } }
        ]
      },
      dependencies: []
    };
    castSpell(this.world, playerEid, testSpell);
  }, 2000);
}
```

---

#### é—®é¢˜4: èŠ‚ç‚¹è¿æ¥é—®é¢˜

**ç—‡çŠ¶ï¼š**
- æ— æ³•è¿æ¥èŠ‚ç‚¹
- è¿æ¥åç«‹å³æ–­å¼€
- è¿æ¥åˆ°äº†é”™è¯¯çš„handle

**å®šä½æ­¥éª¤ï¼š**

1. **æ£€æŸ¥handleé…ç½®**
   ```typescript
   // åœ¨èŠ‚ç‚¹ç»„ä»¶ä¸­æ‰“å°handleä¿¡æ¯
   <Handle
     type="source"
     position={Position.Right}
     id="output"
     onConnect={(params) => console.log('Connected:', params)}
   />
   ```

2. **æ£€æŸ¥è¿æ¥éªŒè¯**
   ```typescript
   // åœ¨ FunctionalEditor.tsx çš„ onConnect ä¸­
   const onConnect = useCallback((connection: Connection) => {
     console.log('Attempting connection:', connection);
     // ReactFlow çš„è¿æ¥éªŒè¯é€»è¾‘
   }, []);
   ```

3. **æ£€æŸ¥å‚æ•°æ¨¡å¼**
   ```typescript
   // å¯¹äºDynamicFunctionNodeï¼Œå‚æ•°æ¨¡å¼ä¼šå½±å“handleæ•°é‡
   const mode = data.parameterModes?.[paramName]?.current;
   if (mode === 'literal-xy') {
     // åº”è¯¥æœ‰2ä¸ªhandleï¼šdx, dy
   }
   ```

**å¸¸è§é”™è¯¯åŸå› ï¼š**
- **handleç±»å‹ä¸åŒ¹é…**ï¼šsourceè¿æ¥åˆ°sourceï¼Œæˆ–targetè¿æ¥åˆ°target
- **handle IDå†²çª**ï¼šå¤šä¸ªhandleä½¿ç”¨äº†ç›¸åŒçš„ID
- **åŠ¨æ€handleæœªæ›´æ–°**ï¼šå‚æ•°æ¨¡å¼åˆ‡æ¢åhandleæ²¡æœ‰é‡æ–°ç”Ÿæˆ

---

#### é—®é¢˜5: æ€§èƒ½é—®é¢˜

**ç—‡çŠ¶ï¼š**
- ç¼–è¾‘å™¨å¡é¡¿
- æ±‚å€¼é€Ÿåº¦æ…¢
- æ¸¸æˆå¸§ç‡ä¸‹é™

**å®šä½æ­¥éª¤ï¼š**

1. **æ£€æŸ¥ç¼“å­˜æ•ˆæœ**
   ```typescript
   // åœ¨ Evaluator ä¸­æ£€æŸ¥ç¼“å­˜å‘½ä¸­ç‡
   const stats = evaluator.getCacheStats();
   console.log('Cache size:', stats.size);
   console.log('Cache keys:', stats.keys);
   ```

2. **åˆ†æé€’å½’æ·±åº¦**
   ```typescript
   // åœ¨ evalFunctionCall ä¸­
   console.log('Call stack depth:', this.callStack.length);
   if (this.callStack.length > 100) {
     console.warn('Deep recursion detected!');
   }
   ```

3. **æ£€æŸ¥å›¾å¤æ‚åº¦**
   ```typescript
   console.log('Total nodes:', nodes.length);
   console.log('Total edges:', edges.length);
   // å¦‚æœèŠ‚ç‚¹æ•° > 100ï¼Œè€ƒè™‘ä¼˜åŒ–
   ```

**ä¼˜åŒ–å»ºè®®ï¼š**
- **æ¸…é™¤ç¼“å­˜**ï¼šå¦‚æœç¼“å­˜è¿‡å¤§ï¼Œè°ƒç”¨ `evaluator.clearCache()`
- **é¿å…æ·±åº¦é€’å½’**ï¼šæ£€æŸ¥é€’å½’æ˜¯å¦æœ‰ç»ˆæ­¢æ¡ä»¶
- **å‡å°‘ä¸å¿…è¦çš„é‡æ–°æ±‚å€¼**ï¼šä½¿ç”¨Reactçš„ `useMemo` ç¼“å­˜AST

---

### è°ƒè¯•å·¥å…·æ¨è

1. **React DevTools**
   - æ£€æŸ¥ç»„ä»¶çŠ¶æ€å’Œprops
   - è¿½è¸ªReactFlowçš„èŠ‚ç‚¹/è¾¹çŠ¶æ€

2. **Chrome DevTools Sources**
   - åœ¨å…³é”®å‡½æ•°è®¾ç½®æ–­ç‚¹ï¼š
     - `flowToIR` å‡½æ•°å…¥å£
     - `Evaluator.evaluate` æ–¹æ³•
     - `castSpell` å‡½æ•°

3. **Consoleæ—¥å¿—ç­–ç•¥**
   ```typescript
   // ä½¿ç”¨åˆ†çº§æ—¥å¿—
   const DEBUG = true;
   function debugLog(level: 'info' | 'warn' | 'error', ...args: any[]) {
     if (!DEBUG) return;
     console[level]('[SpellCompiler]', ...args);
   }
   ```

4. **ASTå¯è§†åŒ–**
   - ä½¿ç”¨ç¼–è¾‘å™¨å³ä¾§çš„ ASTVisualizer ç»„ä»¶
   - éªŒè¯ASTç»“æ„æ˜¯å¦ç¬¦åˆé¢„æœŸ

---

## æ‰©å±•å¼€å‘æŒ‡å—

### æ‰©å±•1: æ·»åŠ æ–°çš„å‡½æ•°åº“å‡½æ•°

**æ­¥éª¤ï¼š**

1. **é€‰æ‹©åˆé€‚çš„æ¨¡å—**
   - æ•°å­¦å‡½æ•° â†’ `math.ts`
   - é€»è¾‘å‡½æ•° â†’ `logic.ts`
   - åˆ—è¡¨å‡½æ•° â†’ `list.ts`
   - å‘é‡å‡½æ•° â†’ `vector.ts`
   - å­—ç¬¦ä¸²å‡½æ•° â†’ `string.ts`
   - æ¸¸æˆäº¤äº’ â†’ `game.ts`
   - å¦‚æœä¸å±äºä»¥ä¸Šä»»ä½•ç±»åˆ«ï¼Œåˆ›å»ºæ–°æ¨¡å—

2. **å®šä¹‰å‡½æ•°è§„èŒƒ**
   ```typescript
   // ç¤ºä¾‹ï¼šæ·»åŠ å¹³æ–¹å‡½æ•°åˆ° math.ts
   const squareFunction: FunctionSpec = {
     fullName: 'math::square',
     params: ['x'],
     fn: (x) => {
       if (typeof x !== 'number') {
         throw new Error('square expects a number');
       }
       return x * x;
     },
     ui: {
       category: 'math',
       label: 'Square',
       description: 'Calculate the square of a number'
     }
   };
   ```

3. **æ·»åŠ åˆ°æ¨¡å—å¯¼å‡º**
   ```typescript
   // åœ¨ math.ts çš„ mathFunctions æ•°ç»„ä¸­æ·»åŠ 
   export const mathFunctions: FunctionSpec[] = [
     // ... ç°æœ‰å‡½æ•°
     squareFunction
   ];
   ```

4. **æµ‹è¯•å‡½æ•°**
   - åœ¨ç¼–è¾‘å™¨ä¸­åˆ›å»ºèŠ‚ç‚¹æµ‹è¯•
   - éªŒè¯ç±»å‹æ£€æŸ¥å’Œé”™è¯¯å¤„ç†

**ç¤ºä¾‹ï¼šæ·»åŠ ä¸‰è§’å‡½æ•°**

```typescript
// åœ¨ math.ts ä¸­æ·»åŠ 
const sinFunction: FunctionSpec = {
  fullName: 'math::sin',
  params: ['angle'],
  fn: (angle) => {
    if (typeof angle !== 'number') {
      throw new Error('sin expects a number (radians)');
    }
    return Math.sin(angle);
  },
  ui: {
    category: 'math',
    label: 'Sine',
    description: 'Calculate sine of angle (in radians)'
  }
};

const cosFunction: FunctionSpec = {
  fullName: 'math::cos',
  params: ['angle'],
  fn: (angle) => {
    if (typeof angle !== 'number') {
      throw new Error('cos expects a number (radians)');
    }
    return Math.cos(angle);
  },
  ui: {
    category: 'math',
    label: 'Cosine',
    description: 'Calculate cosine of angle (in radians)'
  }
};

export const mathFunctions: FunctionSpec[] = [
  // ... ç°æœ‰å‡½æ•°
  sinFunction,
  cosFunction
];
```

---

### æ‰©å±•2: æ·»åŠ æ–°çš„èŠ‚ç‚¹ç±»å‹

**æ­¥éª¤ï¼š**

1. **å®šä¹‰èŠ‚ç‚¹æ•°æ®ç±»å‹**
   ```typescript
   // åœ¨ src/editor/types/flowTypes.ts ä¸­
   export interface MyCustomNodeData {
     label: string;
     value: number;
     // ... å…¶ä»–æ•°æ®å­—æ®µ
   }
   ```

2. **åˆ›å»ºèŠ‚ç‚¹ç»„ä»¶**
   ```typescript
   // åœ¨ src/editor/components/nodes/MyCustomNode.tsx
   import { memo } from 'react';
   import { Handle, Position } from 'reactflow';

   export const MyCustomNode = memo(({ data }: { data: MyCustomNodeData }) => {
     return (
       <div className="custom-node">
         <Handle type="target" position={Position.Left} id="input" />
         <div>{data.label}</div>
         <input
           type="number"
           value={data.value}
           onChange={(e) => {
             // æ›´æ–°èŠ‚ç‚¹æ•°æ®
             data.onChange?.(parseFloat(e.target.value));
           }}
         />
         <Handle type="source" position={Position.Right} id="output" />
       </div>
     );
   });
   ```

3. **æ³¨å†ŒèŠ‚ç‚¹ç±»å‹**
   ```typescript
   // åœ¨ FunctionalEditor.tsx ä¸­
   const nodeTypes = {
     // ... ç°æœ‰èŠ‚ç‚¹ç±»å‹
     myCustom: MyCustomNode
   };
   ```

4. **æ·»åŠ åˆ°flowToIRç¼–è¯‘å™¨**
   ```typescript
   // åœ¨ flowToIR.ts çš„ convertNode å‡½æ•°ä¸­
   function convertNode(node: FlowNode, ...): ASTNode {
     switch (node.type) {
       // ... ç°æœ‰case
       case 'myCustom': {
         const data = node.data as MyCustomNodeData;
         // è½¬æ¢é€»è¾‘
         return {
           type: 'Literal',
           value: data.value
         };
       }
     }
   }
   ```

5. **æ·»åŠ åˆ›å»ºæŒ‰é’®**
   ```typescript
   // åœ¨ FunctionalEditor.tsx çš„UIä¸­
   <Button onClick={() => addNode('myCustom', { label: 'Custom', value: 0 })}>
     + My Custom Node
   </Button>
   ```

---

### æ‰©å±•3: æ·»åŠ æ–°çš„è§¦å‘å™¨ç±»å‹

**åœºæ™¯ï¼š**
å¸Œæœ›æ³•æœ¯åœ¨ç‰¹å®šæ¸¸æˆäº‹ä»¶æ—¶è§¦å‘ï¼ˆå¦‚ï¼šç©å®¶è¡€é‡ä½äº30%ï¼‰

**æ­¥éª¤ï¼š**

1. **å®šä¹‰è§¦å‘å™¨å¸¸é‡**
   ```typescript
   // åœ¨ src/game/events.ts ä¸­
   export const GameEvents = {
     // ... ç°æœ‰äº‹ä»¶
     PLAYER_LOW_HEALTH: 'playerLowHealth'
   };
   ```

2. **åœ¨TriggerTypeNodeä¸­æ·»åŠ é€‰é¡¹**
   ```typescript
   // åœ¨ TriggerTypeNode.tsx ä¸­
   const triggerOptions = [
     { value: 'onEnemyNearby', label: 'Enemy Nearby' },
     { value: 'onBossSpawn', label: 'Boss Spawned' },
     // æ·»åŠ æ–°è§¦å‘å™¨
     { value: 'onPlayerLowHealth', label: 'Player Low Health' }
   ];
   ```

3. **åœ¨æ¸¸æˆåœºæ™¯ä¸­è§¦å‘äº‹ä»¶**
   ```typescript
   // åœ¨å…³å¡åœºæ™¯çš„ update() æ–¹æ³•ä¸­
   update(time: number, delta: number) {
     const playerHealth = Health.current[playerEid];
     const playerMaxHealth = Health.max[playerEid];

     if (playerHealth / playerMaxHealth < 0.3) {
       // è§¦å‘ä½è¡€é‡äº‹ä»¶
       EventBus.emit(GameEvents.PLAYER_LOW_HEALTH, {
         eid: playerEid,
         health: playerHealth,
         maxHealth: playerMaxHealth
       });
     }
   }
   ```

4. **æ³•æœ¯ç³»ç»Ÿç›‘å¬äº‹ä»¶**
   ```typescript
   // åœ¨å…³å¡åœºæ™¯çš„ create() ä¸­
   EventBus.on(GameEvents.PLAYER_LOW_HEALTH, (data) => {
     const spells = getSpells();
     const matchingSpells = spells.filter(
       s => s.trigger === 'onPlayerLowHealth'
     );
     matchingSpells.forEach(spell => {
       castSpell(this.world, data.eid, spell);
     });
   });
   ```

---

### æ‰©å±•4: æ·»åŠ æ–°çš„å‚æ•°æ¨¡å¼

**åœºæ™¯ï¼š**
æŸäº›å‡½æ•°éœ€è¦ç‰¹æ®Šçš„è¾“å…¥æ–¹å¼ï¼ˆå¦‚ï¼šé¢œè‰²é€‰æ‹©å™¨ï¼‰

**æ­¥éª¤ï¼š**

1. **å®šä¹‰å‚æ•°æ¨¡å¼**
   ```typescript
   // åœ¨ functionRegistry.ts ä¸­å®šä¹‰æ–°æ¨¡å¼
   export interface ColorMode {
     mode: 'color';
     label: string;
     params: ['color'];  // å•ä¸ªé¢œè‰²å‚æ•°
   }
   ```

2. **åœ¨å‡½æ•°è§„èŒƒä¸­å£°æ˜**
   ```typescript
   // åœ¨å®šä¹‰å‡½æ•°æ—¶
   const setColorFunction: FunctionSpec = {
     fullName: 'game::setColor',
     params: ['target', 'color'],
     fn: (target, color) => {
       // å®ç°é€»è¾‘
     },
     parameterModes: {
       color: [
         {
           mode: 'color',
           label: 'Color Picker',
           params: ['color']
         },
         {
           mode: 'rgb',
           label: 'RGB Values',
           params: ['r', 'g', 'b']
         }
       ]
     }
   };
   ```

3. **åœ¨DynamicFunctionNodeä¸­å¤„ç†**
   ```typescript
   // åœ¨ DynamicFunctionNode.tsx ä¸­
   const renderParameterInput = (paramName: string, mode: string) => {
     if (mode === 'color') {
       return (
         <input
           type="color"
           onChange={(e) => {
             // å¤„ç†é¢œè‰²é€‰æ‹©
           }}
         />
       );
     }
     // ... å…¶ä»–æ¨¡å¼
   };
   ```

4. **åœ¨flowToIRä¸­è½¬æ¢**
   ```typescript
   // åœ¨ flowToIR.ts çš„ convertNode ä¸­
   if (currentMode === 'rgb') {
     // åˆæˆRGBè°ƒç”¨ï¼šcolor::rgb(r, g, b)
     args.push({
       type: 'FunctionCall',
       function: 'color::rgb',
       args: [arg1, arg2, arg3]
     });
   }
   ```

---

### æ‰©å±•5: æ·»åŠ æ–°çš„æ¸¸æˆå…³å¡

**æ­¥éª¤ï¼š**

1. **åˆ›å»ºåœºæ™¯æ–‡ä»¶**
   ```typescript
   // åœ¨ src/game/scenes/levels/Level21.ts
   import { BaseGameSceneWithUi } from '../base/BaseGameSceneWithUi';

   export class Level21 extends BaseGameSceneWithUi {
     constructor() {
       super({ key: 'Level21' });
     }

     preload() {
       // åŠ è½½èµ„æº
       this.load.image('tileset', 'assets/level21/tileset.png');
     }

     create() {
       super.create();
       // åˆ›å»ºå…³å¡å†…å®¹
       this.createMap();
       this.createPlayer();
       this.createEnemies();
       this.setupSpells();
     }

     update(time: number, delta: number) {
       super.update(time, delta);
       // æ›´æ–°é€»è¾‘
     }

     private setupSpells() {
       // åŠ è½½æ³•æœ¯å¹¶ç›‘å¬è§¦å‘å™¨
       const spells = getSpells();
       EventBus.on('enemyNearby', (data) => {
         const spell = spells.find(s => s.trigger === 'onEnemyNearby');
         if (spell) {
           castSpell(this.world, this.playerEid, spell);
         }
       });
     }
   }
   ```

2. **æ³¨å†Œåœºæ™¯**
   ```typescript
   // åœ¨ Game.tsx ä¸­
   import { Level21 } from './scenes/levels/Level21';

   const config: Phaser.Types.Core.GameConfig = {
     scene: [
       // ... ç°æœ‰åœºæ™¯
       Level20,
       Level21  // æ·»åŠ æ–°åœºæ™¯
     ]
   };
   ```

3. **æ·»åŠ åˆ°å…³å¡é…ç½®**
   ```typescript
   // åœ¨ src/game/scenes/sceneConfig.ts ä¸­
   export const sceneConfig = {
     // ... ç°æœ‰é…ç½®
     21: {
       key: 'Level21',
       name: 'Level 21: The Final Trial',
       description: 'Face the ultimate challenge',
       unlocked: true  // æˆ–è®¾ç½®è§£é”æ¡ä»¶
     }
   };
   ```

4. **æ›´æ–°å…³å¡é€‰æ‹©ç•Œé¢**
   ```typescript
   // LevelSelectInterface ä¼šè‡ªåŠ¨è¯»å– sceneConfig
   // å¦‚æœéœ€è¦è‡ªå®šä¹‰UIï¼Œå¯ä»¥ä¿®æ”¹ LevelSelectInterface.tsx
   ```

---

### æ‰©å±•6: ä¼˜åŒ–å’Œæ€§èƒ½æå‡

**ä¼˜åŒ–ç­–ç•¥ï¼š**

1. **ASTç¼“å­˜**
   ```typescript
   // ç¼“å­˜ç¼–è¯‘ç»“æœ
   const astCache = new Map<string, { ast: ASTNode; functions: FunctionDefinition[] }>();

   function flowToIRCached(nodes: Node[], edges: Edge[]) {
     const key = JSON.stringify({ nodes, edges });
     if (astCache.has(key)) {
       return astCache.get(key)!;
     }
     const result = flowToIR(nodes, edges);
     astCache.set(key, result);
     return result;
   }
   ```

2. **æƒ°æ€§å‡½æ•°æ³¨å†Œ**
   ```typescript
   // åªæ³¨å†Œå½“å‰å…³å¡éœ€è¦çš„å‡½æ•°
   function registerOnDemand(evaluator: Evaluator, requiredFunctions: string[]) {
     const allFunctions = coreLibraryFunctions;
     allFunctions
       .filter(spec => requiredFunctions.includes(spec.fullName))
       .forEach(spec => evaluator.registerFunction(spec));
   }
   ```

3. **ReactFlowæ€§èƒ½ä¼˜åŒ–**
   ```typescript
   // ä½¿ç”¨ memo é¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“
   const MemoizedNode = memo(MyNode, (prev, next) => {
     return prev.data.value === next.data.value;
   });
   ```

4. **æ¸¸æˆå¾ªç¯ä¼˜åŒ–**
   ```typescript
   // ä½¿ç”¨å¯¹è±¡æ± å‡å°‘GCå‹åŠ›
   class ProjectilePool {
     private pool: Phaser.Physics.Sprite[] = [];

     get(): Phaser.Physics.Sprite {
       return this.pool.pop() || this.scene.physics.add.sprite(0, 0, 'bullet');
     }

     release(sprite: Phaser.Physics.Sprite) {
       sprite.setActive(false).setVisible(false);
       this.pool.push(sprite);
     }
   }
   ```

---

## é™„å½•

### A. ASTç¤ºä¾‹

**ç¤ºä¾‹1ï¼šç®€å•ç®—æœ¯ `(3 + 5) * 2`**

```json
{
  "type": "FunctionCall",
  "function": "multiply",
  "args": [
    {
      "type": "FunctionCall",
      "function": "add",
      "args": [
        { "type": "Literal", "value": 3 },
        { "type": "Literal", "value": 5 }
      ]
    },
    { "type": "Literal", "value": 2 }
  ]
}
```

**ç¤ºä¾‹2ï¼šæ¡ä»¶è¡¨è¾¾å¼ `if x > 0 then x else -x`**

```json
{
  "type": "IfExpression",
  "condition": {
    "type": "FunctionCall",
    "function": "gt",
    "args": [
      { "type": "Identifier", "name": "x" },
      { "type": "Literal", "value": 0 }
    ]
  },
  "thenBranch": { "type": "Identifier", "name": "x" },
  "elseBranch": {
    "type": "FunctionCall",
    "function": "negate",
    "args": [{ "type": "Identifier", "name": "x" }]
  }
}
```

**ç¤ºä¾‹3ï¼šLambdaè¡¨è¾¾å¼ `(x, y) => x + y`**

```json
{
  "type": "Lambda",
  "params": ["x", "y"],
  "body": {
    "type": "FunctionCall",
    "function": "add",
    "args": [
      { "type": "Identifier", "name": "x" },
      { "type": "Identifier", "name": "y" }
    ]
  }
}
```

---

### B. å¸¸è§é”™è¯¯ä»£ç 

| é”™è¯¯ä¿¡æ¯ | åŸå›  | è§£å†³æ–¹æ³• |
|---------|------|---------|
| `No output node found` | å›¾ä¸­ç¼ºå°‘OutputèŠ‚ç‚¹ | æ·»åŠ OutputèŠ‚ç‚¹ |
| `Undefined identifier: X` | å˜é‡æˆ–å‡½æ•°åä¸å­˜åœ¨ | æ£€æŸ¥æ‹¼å†™ï¼Œç¡®ä¿å‡½æ•°å·²æ³¨å†Œ |
| `Function not found: X` | å‡½æ•°æœªåœ¨å‡½æ•°è¡¨ä¸­æ³¨å†Œ | ç¡®ä¿è°ƒç”¨äº†registerFunction |
| `Type mismatch: expected number, got string` | å‚æ•°ç±»å‹é”™è¯¯ | æ£€æŸ¥è¾“å…¥å€¼çš„ç±»å‹ |
| `If condition must be boolean` | IfèŠ‚ç‚¹çš„conditionä¸æ˜¯å¸ƒå°”å€¼ | ä½¿ç”¨æ¯”è¾ƒå‡½æ•°(gt, lt, eqç­‰) |
| `Cannot call non-function` | å°è¯•è°ƒç”¨éå‡½æ•°å€¼ | ç¡®ä¿æ ‡è¯†ç¬¦æŒ‡å‘å‡½æ•° |
| `Too many arguments` | å‚æ•°æ•°é‡è¶…è¿‡å‡½æ•°å®šä¹‰ | æ£€æŸ¥å‡½æ•°ç­¾å |
| `Source node not found` | flowToIRä¸­è¾¹å¼•ç”¨çš„æºèŠ‚ç‚¹ä¸å­˜åœ¨ | æ£€æŸ¥èŠ‚ç‚¹IDæ˜¯å¦ä¸€è‡´ |

---

### C. è°ƒè¯•æ£€æŸ¥æ¸…å•

**ç¼–è¯‘é—®é¢˜ï¼š**
- [ ] å›¾ä¸­æœ‰ä¸”ä»…æœ‰1ä¸ªOutputèŠ‚ç‚¹
- [ ] OutputèŠ‚ç‚¹æœ‰è¾“å…¥è¿æ¥
- [ ] æ‰€æœ‰Lambdaå‡½æ•°æœ‰å¯¹åº”çš„FunctionOutèŠ‚ç‚¹
- [ ] èŠ‚ç‚¹IDæ²¡æœ‰é‡å¤
- [ ] è¾¹çš„sourceå’Œtargetéƒ½å­˜åœ¨

**æ‰§è¡Œé—®é¢˜ï¼š**
- [ ] æ‰€æœ‰ä½¿ç”¨çš„å‡½æ•°éƒ½å·²æ³¨å†Œ
- [ ] Lambdaçš„å‚æ•°åä¸IdentifieråŒ¹é…
- [ ] å‚æ•°ç±»å‹æ­£ç¡®ï¼ˆnumber/string/boolean/ç­‰ï¼‰
- [ ] æ²¡æœ‰å¾ªç¯ä¾èµ–ï¼ˆæ— é™é€’å½’ï¼‰
- [ ] é—­åŒ…ç¯å¢ƒæ­£ç¡®æ•è·

**æ¸¸æˆé›†æˆé—®é¢˜ï¼š**
- [ ] æ³•æœ¯å·²ä¿å­˜åˆ°localStorage
- [ ] è§¦å‘å™¨ç±»å‹ä¸äº‹ä»¶åŒ¹é…
- [ ] game::*å‡½æ•°å·²æ³¨å†Œ
- [ ] GameWorldå¼•ç”¨æœ‰æ•ˆ
- [ ] ä¾èµ–å‡½æ•°å·²åŒ…å«åœ¨spell.dependencies

---

### D. é¡¹ç›®ç»Ÿè®¡

```
æ€»æ–‡ä»¶æ•°ï¼š139 ä¸ª TypeScript/TSX æ–‡ä»¶

ç¼–è¾‘å™¨æ¨¡å—ï¼š47 æ–‡ä»¶
â”œâ”€ ASTæ ¸å¿ƒï¼š4 æ–‡ä»¶
â”œâ”€ UIç»„ä»¶ï¼š20 æ–‡ä»¶
â”œâ”€ å‡½æ•°åº“ï¼š7 æ–‡ä»¶
â”œâ”€ å·¥å…·å‡½æ•°ï¼š6 æ–‡ä»¶
â””â”€ æµ‹è¯•æ–‡ä»¶ï¼š5 æ–‡ä»¶

æ¸¸æˆæ¨¡å—ï¼š87 æ–‡ä»¶
â”œâ”€ Bossç³»ç»Ÿï¼š35 æ–‡ä»¶
â”‚  â”œâ”€ æŠ€èƒ½ï¼š12 æ–‡ä»¶ï¼ˆPhase1: 4, Phase2: 5, Phase3: 3ï¼‰
â”‚  â”œâ”€ AIå’ŒçŠ¶æ€ï¼š10 æ–‡ä»¶
â”‚  â””â”€ è§†è§‰æ•ˆæœï¼š8 æ–‡ä»¶
â”œâ”€ åœºæ™¯ç³»ç»Ÿï¼š22 æ–‡ä»¶ï¼ˆ20ä¸ªå…³å¡ + é…ç½®ï¼‰
â”œâ”€ æ³•æœ¯ç³»ç»Ÿï¼š2 æ–‡ä»¶
â”œâ”€ ç»„ä»¶ç³»ç»Ÿï¼š8 æ–‡ä»¶ï¼ˆECSï¼‰
â””â”€ å…¶ä»–ï¼š20 æ–‡ä»¶

ä»£ç è¡Œæ•°ä¼°ç®—ï¼š
- æ ¸å¿ƒç¼–è¯‘å™¨å’Œè§£é‡Šå™¨ï¼š~1500è¡Œ
- å‡½æ•°åº“ï¼š~1000è¡Œ
- UIç»„ä»¶ï¼š~3000è¡Œ
- æ¸¸æˆç³»ç»Ÿï¼š~5000è¡Œ
- æ€»è®¡ï¼š~10,000+ è¡Œä»£ç 
```

---

### E. å‚è€ƒèµ„æº

**å­¦ä¹ èµ„æºï¼š**
- ReactFlow æ–‡æ¡£ï¼šhttps://reactflow.dev/
- Phaser 3 æ–‡æ¡£ï¼šhttps://photonstorm.github.io/phaser3-docs/
- TypeScript æ‰‹å†Œï¼šhttps://www.typescriptlang.org/docs/

**ç›¸å…³æ¦‚å¿µï¼š**
- æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰
- è§£é‡Šå™¨æ¨¡å¼
- å‡½æ•°å¼ç¼–ç¨‹ï¼ˆé—­åŒ…ã€æŸ¯é‡ŒåŒ–ã€é«˜é˜¶å‡½æ•°ï¼‰
- ECSæ¶æ„ï¼ˆEntity-Component-Systemï¼‰
- å‘å¸ƒ-è®¢é˜…æ¨¡å¼

---

## æ€»ç»“

SpellCompiler-web æ˜¯ä¸€ä¸ªå¤æ‚ä½†ç»“æ„æ¸…æ™°çš„ç³»ç»Ÿï¼Œæ ¸å¿ƒæµç¨‹ä¸ºï¼š

```
å¯è§†åŒ–ç¼–è¾‘ â†’ ç¼–è¯‘ä¸ºAST â†’ è§£é‡Šå™¨æ‰§è¡Œ â†’ æ¸¸æˆæ•ˆæœ
```

å…³é”®æ¨¡å—ä¹‹é—´çš„èŒè´£åˆ†æ˜ï¼š
- **flowToIR**ï¼šè´Ÿè´£ç¼–è¯‘ï¼ˆå›¾â†’ASTï¼‰
- **Evaluator**ï¼šè´Ÿè´£æ‰§è¡Œï¼ˆASTâ†’ç»“æœï¼‰
- **FunctionLibrary**ï¼šæä¾›æ ‡å‡†åŠŸèƒ½
- **castSpell**ï¼šè¿æ¥ç¼–è¾‘å™¨å’Œæ¸¸æˆ

ç†è§£è¿™äº›æ ¸å¿ƒæ¨¡å—åï¼Œä½ å¯ä»¥ï¼š
1. **å¿«é€Ÿå®šä½BUG**ï¼šæ ¹æ®é”™è¯¯ä¿¡æ¯æ‰¾åˆ°å¯¹åº”æ¨¡å—
2. **æ‰©å±•æ–°åŠŸèƒ½**ï¼šæ·»åŠ å‡½æ•°ã€èŠ‚ç‚¹ã€è§¦å‘å™¨ç­‰
3. **ä¼˜åŒ–æ€§èƒ½**ï¼šè¯†åˆ«ç“¶é¢ˆå¹¶åº”ç”¨ä¼˜åŒ–ç­–ç•¥

å¸Œæœ›è¿™ä»½æ–‡æ¡£èƒ½å¸®åŠ©ä½ æ·±å…¥ç†è§£æ³•æœ¯ç¼–è¾‘å™¨çš„è¿ä½œæœºåˆ¶ï¼ğŸš€
